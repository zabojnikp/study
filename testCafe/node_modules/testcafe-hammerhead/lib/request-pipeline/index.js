'use strict';

exports.__esModule = true;
exports.run = run;

var _destinationRequest = require('./destination-request');

var _destinationRequest2 = _interopRequireDefault(_destinationRequest);

var _fileRequest = require('./file-request');

var _fileRequest2 = _interopRequireDefault(_fileRequest);

var _context = require('./context');

var _context2 = _interopRequireDefault(_context);

var _headerTransforms = require('./header-transforms');

var headerTransforms = _interopRequireWildcard(_headerTransforms);

var _resources = require('../processing/resources');

var _messages = require('../messages');

var _connectionResetGuard = require('./connection-reset-guard');

var _connectionResetGuard2 = _interopRequireDefault(_connectionResetGuard);

var _sameOriginPolicy = require('./xhr/same-origin-policy');

var _http = require('../utils/http');

var _upload = require('../upload');

var _websocket = require('./websocket');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var EVENT_SOURCE_REQUEST_TIMEOUT = 60 * 60 * 1000;

// Stages
var stages = {
    0: function () {
        var _ref = _asyncToGenerator(function* (ctx, next) {
            if (ctx.isPage && !ctx.isIframe && !ctx.isHtmlImport) ctx.session.onPageRequest(ctx);

            ctx.reqBody = yield (0, _http.fetchBody)(ctx.req);

            next();
        });

        function fetchProxyRequestBody(_x, _x2) {
            return _ref.apply(this, arguments);
        }

        return fetchProxyRequestBody;
    }(),

    1: function sendDestinationRequest(ctx, next) {
        var opts = createReqOpts(ctx);

        if (ctx.isSpecialPage) {
            mockDestinationResponseForSpecialPage(ctx);
            next();
        } else {
            var req = ctx.isFileProtocol ? new _fileRequest2.default(opts) : new _destinationRequest2.default(opts);

            req.on('response', function (res) {
                ctx.destRes = res;
                next();
            });

            req.on('error', function () {
                ctx.hasDestReqErr = true;
            });

            req.on('fatalError', function (err) {
                return error(ctx, err);
            });

            req.on('socketHangUp', function () {
                return ctx.req.socket.end();
            });
        }
    },

    2: function checkSameOriginPolicyCompliance(ctx, next) {
        ctx.buildContentInfo();

        if ((ctx.isXhr || ctx.isFetch) && !ctx.contentInfo.isNotModified && !(0, _sameOriginPolicy.check)(ctx)) {
            ctx.closeWithError(_sameOriginPolicy.SAME_ORIGIN_CHECK_FAILED_STATUS_CODE);
            return;
        }

        next();
    },

    3: function decideOnProcessingStrategy(ctx, next) {
        if (ctx.contentInfo.requireProcessing && ctx.destRes.statusCode === 204) ctx.destRes.statusCode = 200;

        if (ctx.isWebSocket) {
            (0, _websocket.respondOnWebSocket)(ctx);

            return;
        }
        // NOTE: Just pipe the content body to the browser if we don't need to process it.
        else if (!ctx.contentInfo.requireProcessing) {
                sendResponseHeaders(ctx);

                if (!ctx.isSpecialPage) {
                    ctx.destRes.pipe(ctx.res);

                    // NOTE: sets 60 minutes timeout for the "event source" requests instead of 2 minutes by default
                    if (ctx.dest.isEventSource) {
                        ctx.req.setTimeout(EVENT_SOURCE_REQUEST_TIMEOUT);
                        ctx.req.on('close', function () {
                            return ctx.destRes.destroy();
                        });
                    }
                } else ctx.res.end('');

                return;
            }

        next();
    },

    4: function () {
        var _ref2 = _asyncToGenerator(function* (ctx, next) {
            if (ctx.isSpecialPage) ctx.destResBody = new Buffer(0);else ctx.destResBody = yield (0, _http.fetchBody)(ctx.destRes);

            // NOTE: Sometimes the underlying socket emits an error event. But if we have a response body,
            // we can still process such requests. (B234324)
            if (ctx.hasDestReqErr && isDestResBodyMalformed(ctx)) {
                error(ctx, (0, _messages.getText)(_messages.MESSAGE.destConnectionTerminated, ctx.dest.url));

                return;
            }

            next();
        });

        function fetchContent(_x3, _x4) {
            return _ref2.apply(this, arguments);
        }

        return fetchContent;
    }(),

    5: function () {
        var _ref3 = _asyncToGenerator(function* (ctx, next) {
            try {
                ctx.destResBody = yield (0, _resources.process)(ctx);
                next();
            } catch (err) {
                error(ctx, err);
            }
        });

        function processContent(_x5, _x6) {
            return _ref3.apply(this, arguments);
        }

        return processContent;
    }(),

    6: function sendProxyResponse(ctx) {
        sendResponseHeaders(ctx);

        (0, _connectionResetGuard2.default)(function () {
            ctx.res.write(ctx.destResBody);
            ctx.res.end();
        });
    }
};

// Utils
function createReqOpts(ctx) {
    var bodyWithUploads = (0, _upload.inject)(ctx.req.headers['content-type'], ctx.reqBody);

    // NOTE: First, we should rewrite the request body, because the 'content-length' header will be built based on it.
    if (bodyWithUploads) ctx.reqBody = bodyWithUploads;

    // NOTE: All headers, including 'content-length', are built here.
    var headers = headerTransforms.forRequest(ctx);
    var proxy = ctx.session.externalProxySettings;
    var options = {
        url: ctx.dest.url,
        protocol: ctx.dest.protocol,
        hostname: ctx.dest.hostname,
        host: ctx.dest.host,
        port: ctx.dest.port,
        path: ctx.dest.partAfterHost,
        method: ctx.req.method,
        credentials: ctx.session.getAuthCredentials(),
        body: ctx.reqBody,
        isXhr: ctx.isXhr,

        proxy,
        headers
    };

    if (proxy && ctx.dest.protocol === 'http:') {
        options.path = options.protocol + '//' + options.host + options.path;
        options.host = proxy.host;
        options.hostname = proxy.hostname;
        options.port = proxy.port;

        if (proxy.authHeader) headers['proxy-authorization'] = proxy.authHeader;
    }

    return options;
}

function sendResponseHeaders(ctx) {
    var headers = headerTransforms.forResponse(ctx);

    ctx.res.writeHead(ctx.destRes.statusCode, headers);
    ctx.res.addTrailers(ctx.destRes.trailers);
}

function error(ctx, err) {
    if (ctx.isPage && !ctx.isIframe) ctx.session.handlePageError(ctx, err);else if (ctx.isFetch || ctx.isXhr) ctx.req.destroy();else ctx.closeWithError(500, err);
}

function isDestResBodyMalformed(ctx) {
    return !ctx.destResBody || ctx.destResBody.length !== ctx.destRes.headers['content-length'];
}

function mockDestinationResponseForSpecialPage(ctx) {
    ctx.destRes = {
        headers: {
            'content-type': 'text/html',
            'content-length': '0'
        },

        statusCode: 200,
        trailers: {}
    };
}

// API
function run(req, res, serverInfo, openSessions) {
    var ctx = new _context2.default(req, res, serverInfo);

    if (ctx.dispatch(openSessions)) {
        var stageIdx = 0;
        var next = function next() {
            return stages[++stageIdx](ctx, next);
        };

        stages[0](ctx, next);
    } else (0, _http.respond404)(res);
}