'use strict';

exports.__esModule = true;
exports.forRequest = forRequest;
exports.forResponse = forResponse;

var _headers = require('./xhr/headers');

var _headers2 = _interopRequireDefault(_headers);

var _authorization = require('./xhr/authorization');

var _authorization2 = _interopRequireDefault(_authorization);

var _url = require('../utils/url');

var urlUtils = _interopRequireWildcard(_url);

var _url2 = require('url');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Skipping transform
function skip() {
    return void 0;
}

function skipIfStateSnapshotIsApplied(src, ctx) {
    return ctx.restoringStorages ? void 0 : src;
}

function isCrossDomainXhrWithoutCredentials(ctx) {
    return ctx.isXhr && !!ctx.req.headers[_headers2.default.corsSupported] && !ctx.req.headers[_headers2.default.withCredentials] && ctx.dest.reqOrigin !== ctx.dest.domain;
}

function transformAuthorizationHeader(src, ctx) {
    if (src.indexOf(_authorization2.default.valuePrefix) !== -1) return src.replace(_authorization2.default.valuePrefix, '');

    return isCrossDomainXhrWithoutCredentials(ctx) ? void 0 : src;
}

function transformCookieForFetch(src, ctx) {
    var requestCredentials = ctx.req.headers[_headers2.default.fetchRequestCredentials];

    switch (requestCredentials) {
        case 'omit':
            return void 0;
        case 'same-origin':
            return ctx.dest.reqOrigin === ctx.dest.domain ? src : void 0;
        case 'include':
            return src;
        default:
            return void 0;
    }
}

function transformCookie(src, ctx) {
    if (ctx.isXhr) return isCrossDomainXhrWithoutCredentials(ctx) ? void 0 : src;else if (ctx.isFetch) return transformCookieForFetch(src, ctx);

    return src;
}

function resolveAndGetProxyUrl(url, ctx) {
    var _parseUrl = (0, _url2.parse)(url),
        host = _parseUrl.host;

    var isCrossDomain = false;

    if (!host) url = (0, _url2.resolve)(ctx.dest.url, url);

    if (ctx.isIframe && ctx.dest.referer) {
        var isCrossDomainLocationBeforeRedirect = !urlUtils.sameOriginCheck(ctx.dest.referer, ctx.dest.url);
        var isCrossDomainLocationAfterRedirect = !urlUtils.sameOriginCheck(ctx.dest.referer, url);

        isCrossDomain = isCrossDomainLocationBeforeRedirect !== isCrossDomainLocationAfterRedirect;
    }

    return ctx.toProxyUrl(url, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);
}

function transformRefreshHeader(src, ctx) {
    return src.replace(/(url=)(.*)$/i, function (match, prefix, url) {
        return prefix + resolveAndGetProxyUrl(url, ctx);
    });
}

// Request headers
var requestTransforms = Object.assign({
    'host': function host(src, ctx) {
        return ctx.dest.host;
    },
    'referer': function referer(src, ctx) {
        return ctx.dest.referer || void 0;
    },
    'origin': function origin(src, ctx) {
        return ctx.dest.reqOrigin || src;
    },
    'content-length': function contentLength(src, ctx) {
        return ctx.reqBody.length;
    },
    'cookie': skip,
    'if-modified-since': skipIfStateSnapshotIsApplied,
    'if-none-match': skipIfStateSnapshotIsApplied,
    [_headers2.default.requestMarker]: skip,
    [_headers2.default.corsSupported]: skip,
    [_headers2.default.withCredentials]: skip,
    [_headers2.default.origin]: skip,
    [_headers2.default.fetchRequestCredentials]: skip
}, _authorization2.default.headers.reduce(function (obj, header) {
    obj[header] = transformAuthorizationHeader;

    return obj;
}, {}));

var requestForced = {
    'cookie': function cookie(src, ctx) {
        return transformCookie(ctx.session.cookies.getHeader(ctx.dest.url) || void 0, ctx);
    },

    // NOTE: All browsers except Chrome don't send the 'Origin' header in case of the same domain XHR requests.
    // So, if the request is actually cross-domain, we need to force the 'Origin' header to support CORS. (B234325)
    'origin': function origin(src, ctx) {
        var force = (ctx.isXhr || ctx.isFetch) && !src && ctx.dest.domain !== ctx.dest.reqOrigin;

        return force ? ctx.dest.reqOrigin : src;
    }
};

// Response headers
var responseTransforms = {
    'set-cookie': function setCookie(src, ctx) {
        if (src) {
            var cookies = Array.isArray(src) ? src : [src];

            cookies = cookies.filter(function (cookieStr) {
                return !!cookieStr;
            });
            ctx.session.cookies.setByServer(ctx.dest.url, cookies);
        }

        // NOTE: Delete header.
        return void 0;
    },

    // NOTE: Disable Content Security Policy (see http://en.wikipedia.org/wiki/Content_Security_Policy).
    'content-security-policy': skip,
    'content-security-policy-report-only': skip,
    'x-content-security-policy': skip,
    'x-content-security-policy-report-only': skip,
    'x-webkit-csp': skip,

    // NOTE: Even if we are not able to be authorized, we should prevent showing the native credentials window.
    'www-authenticate': skip,

    // NOTE: We perform CORS checks on our side, so we skip the related headers.
    'access-control-allow-origin': skip,

    // NOTE: Change the transform type if we have an iframe with an image as src,
    // because it was transformed to HTML with the image tag.
    'content-type': function contentType(src, ctx) {
        return ctx.contentInfo.isIframeWithImageSrc ? 'text/html' : src;
    },
    'content-length': function contentLength(src, ctx) {
        return ctx.contentInfo.requireProcessing ? ctx.destResBody.length : src;
    },

    'location': function location(src, ctx) {
        // NOTE: The RFC 1945 standard requires location URLs to be absolute. However, most popular browsers
        // accept relative URLs. We transform relative URLs to absolute to correctly handle this situation.
        return resolveAndGetProxyUrl(src, ctx);
    },

    'x-frame-options': function xFrameOptions(src, ctx) {
        if (src.indexOf('ALLOW-FROM') === -1) return src;

        src = src.replace('ALLOW-FROM', '').trim();

        var isCrossDomain = ctx.isIframe && !urlUtils.sameOriginCheck(ctx.dest.url, src);
        var proxiedUrl = ctx.toProxyUrl(src, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);

        return 'ALLOW-FROM ' + proxiedUrl;
    },

    'sourcemap': skip,

    'referrer-policy': function referrerPolicy() {
        return 'unsafe-url';
    },

    'refresh': function refresh(src, ctx) {
        return transformRefreshHeader(src, ctx);
    }
};

var responseForced = {
    [_headers2.default.setCookie]: function (src, ctx) {
        if (ctx.isXhr && ctx.destRes && ctx.destRes.headers && ctx.destRes.headers['set-cookie']) {
            var setCookieHeader = ctx.destRes.headers['set-cookie'];
            var cookieArr = Array.isArray(setCookieHeader) ? setCookieHeader : [setCookieHeader];

            return JSON.stringify(cookieArr);
        }

        return void 0;
    }
};

// Transformation routine
function transformHeaders(srcHeaders, ctx, transformList, forced) {
    var destHeaders = {};

    var applyTransform = function applyTransform(headerName, headers, transforms) {
        var src = headers[headerName];
        var transform = transforms[headerName];
        var dest = transform ? transform(src, ctx) : src;

        if (dest !== void 0) destHeaders[headerName] = dest;
    };

    Object.keys(srcHeaders).forEach(function (headerName) {
        return applyTransform(headerName, srcHeaders, transformList);
    });

    if (forced) Object.keys(forced).forEach(function (headerName) {
        return applyTransform(headerName, destHeaders, forced);
    });

    return destHeaders;
}

// API
function forRequest(ctx) {
    return transformHeaders(ctx.req.headers, ctx, requestTransforms, requestForced);
}

function forResponse(ctx) {
    return transformHeaders(ctx.destRes.headers, ctx, responseTransforms, responseForced);
}